<?php
/**
 * @file
 * Code for the Event feature.
 */

include_once 'events_event.features.inc';

/**
 * Implements hook_menu_alter().
 */
function events_event_menu_alter(&$items) {
  // Disable the user registration page for all users.
  $items['user/register']['access callback'] = FALSE;
  $items['user/password']['page callback'] = FALSE;
  $items['user/login']['access callback'] = FALSE;
}

/**
 * Implements hook_menu().
 */
function events_event_menu() {
  $items['calendar'] = array(
    'title' => 'Calendar',
    'page callback' => 'events_event_calendar',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/v0/fetch-events'] = array(
    'title' => 'Fetch events',
    'page callback' => 'events_event_fetch_events',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/v0/organisations'] = array(
    'title' => 'Fetch organisations',
    'page callback' => 'events_event_fetch_organisations',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/v0/clusters'] = array(
    'title' => 'Fetch clusters',
    'page callback' => 'events_event_fetch_clusters',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/v0/locations'] = array(
    'title' => 'Fetch locations',
    'page callback' => 'events_event_fetch_locations',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/v0/countries'] = array(
    'title' => 'Fetch countries',
    'page callback' => 'events_event_fetch_countries',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/v0/disasters'] = array(
    'title' => 'Fetch disasters',
    'page callback' => 'events_event_fetch_disasters',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/v0/themes'] = array(
    'title' => 'Fetch themes',
    'page callback' => 'events_event_fetch_themes',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['api/v0/categories'] = array(
    'title' => 'Fetch categories',
    'page callback' => 'events_event_fetch_categories',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/v0/timezones'] = array(
    'title' => 'Fetch time zones',
    'page callback' => 'events_event_fetch_timezones',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['api/v0/facets'] = array(
    'title' => 'Fetch facets',
    'page callback' => 'events_event_fetch_facets',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['api/v0/documents'] = array(
    'title' => 'Fetch documents',
    'page callback' => 'events_event_fetch_documents',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['ical'] = array(
    'title' => 'Ical',
    'page callback' => 'events_event_to_ical',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_menu_link_alter().
 */
function events_event_menu_link_alter(&$item) {
  if ($item['link_path'] == 'login') {
    $destination = drupal_get_destination();
    $item['localized_options']['query'] = array('destination' => $destination);
  }
}

/**
 * List of exported term fields.
 */
function events_event_exported_term_fields() {
  return array(
    'field_event_coordination_hub' => array(
      'label' => t('Coordination Hubs', array(), array('context' => 'events')),
      'has_parents' => FALSE,
      'short_key' => 'hub',
      'value_key' => '',
      'bundle' => 'ev_coordination_hub',
      'exposed' => FALSE,
    ),
    'field_event_cluster' => array(
      'label' => t('Clusters', array(), array('context' => 'events')),
      'has_parents' => FALSE,
      'short_key' => 'clu',
      'value_key' => '',
      'bundle' => 'ev_list',
      'exposed' => TRUE,
    ),
    'field_event_category' => array(
      'label' => t('Categories', array(), array('context' => 'events')),
      'has_parents' => FALSE,
      'short_key' => 'cat',
      'value_key' => '',
      'bundle' => 'ev_category',
      'exposed' => TRUE,
    ),
    'field_event_organization' => array(
      'label' => t('Organizations', array(), array('context' => 'events')),
      'has_parents' => FALSE,
      'short_key' => 'org',
      'value_key' => '',
      'bundle' => 'ev_organization',
      'exposed' => TRUE,
    ),
    'field_event_location' => array(
      'label' => t('Location of Event', array(), array('context' => 'events')),
      'has_parents' => TRUE,
      'short_key' => 'loc',
      'value_key' => 'vloc',
      'bundle' => 'ev_location',
      'exposed' => TRUE,
    ),
    'field_event_disasters' => array(
      'label' => t('Disasters', array(), array('context' => 'events')),
      'has_parents' => FALSE,
      'short_key' => 'dis',
      'value_key' => '',
      'bundle' => 'ev_disaster',
      'exposed' => TRUE,
    ),
    'field_event_theme' => array(
      'label' => t('Themes', array(), array('context' => 'events')),
      'has_parents' => FALSE,
      'short_key' => 'the',
      'value_key' => '',
      'bundle' => 'ev_theme',
      'exposed' => TRUE,
    ),
    'field_event_documents:field_document_type' => array(
      'label' => t('Document type', array(), array('context' => 'events')),
      'has_parents' => FALSE,
      'short_key' => 'doct',
      'value_key' => '',
      'bundle' => 'ev_document_type',
      'exposed' => FALSE,
      'node_field' => 'field_event_documents',
      'multifield_field' => 'field_document_type',
    ),
  );
}

/**
 * Page callback for calendar.
 */
function events_event_calendar() {
  $settings = array(
    'timeout' => 25000,
    'base_url' => '',
    'header' => array(
      'left' => 'prev,next today',
      'center' => 'title',
      'right' => 'month,agendaWeek,agendaDay,listYear,upcoming,past',
    ),
    'editable' => FALSE,
    'eventLimit' => TRUE,
    'firstDay' => 1,
    'defaultView' => 'upcoming',
    'weekends' => TRUE,
    'timeFormat' => 'H:mm',
    'timezone' => drupal_get_user_timezone(),
    'views' => array(
      'listYear' => array(
        'buttonText' => t('Year', array(), array('context' => 'events')),
      ),
      'upcoming' => array(),
      'past' => array(),
    ),
    'events' => array(
      'url' => 'api/v0/fetch-events',
      'type' => 'GET',
    ),
    'categories' => _events_event_fetch_categories(),
  );

  // Add caching.
  if (variable_get('events_event_page_cache', 60)) {
    $settings['headers'] = array(
      'Cache-Control' => 'max-age=' . variable_get('events_event_page_cache', 60),
    );
  }

  // Parse query parameters.
  $query_filters = events_event_get_query_filters();

  foreach (events_event_exported_term_fields() as $term_field => $term_field_info) {
    if (!$term_field_info['exposed']) {
      continue;
    }

    // List of available filters visible to the user.
    $settings['availableFilters'][$term_field_info['short_key']] = '';

    // Hard filter, will be added in all calls.
    if ($query_filters[$term_field]['forced']) {
      $settings['events']['data'][$term_field_info['short_key']] = $query_filters[$term_field]['value'];
    }
    else {
      // List of default values for the exposed filters.
      if (isset($query_filters[$term_field])) {
        $settings['defaultFilters'][$term_field_info['short_key']] = $query_filters[$term_field]['value'];
      }
    }
  }

  if (isset($_GET['timezone'])) {
    $settings['timezone'] = $_GET['timezone'];
  };
  $settings['events']['data']['timezone'] = $settings['timezone'];

  if (isset($_GET['view'])) {
    $settings['defaultView'] = $_GET['view'];
  };

  if (isset($_GET['date'])) {
    $settings['defaultDate'] = $_GET['date'];
  };

  drupal_add_library('chosen', 'drupal.chosen');
  drupal_add_js('sites/all/libraries/jspdf/dist/jspdf.min.js');
  drupal_add_js('sites/all/libraries/html2canvas/html2canvas.js');
  drupal_add_js('sites/all/libraries/jspdf/jspdf.plugin.autotable.js');

  drupal_add_js(drupal_get_path('module', 'events_event') . '/events_event.js');

  return theme('fullcalendar_calendar', array(
    'calendar_id' => 'fullcalendar',
    'calendar_settings' => $settings,
  ));
}

/**
 * Fetch events from search api.
 */
function events_event_fetch_events_from_search_api($start = NULL, $end = NULL, $filters = array(), $facets_only = FALSE) {
  $index = search_api_index_load('un_events');
  $query = new SearchApiQuery($index);

  $filter = $query->createFilter('AND');
  if ($start) {
    $filter->condition('field_event_date:value', $start, '>=');
  }
  if ($end) {
    $filter->condition('field_event_date:value', $end, '<=');
  }

  foreach ($filters as $key => $filter_info) {
    if (isset($filter_info['value']) && !empty($filter_info['value'])) {
      $filter->condition($key, $filter_info['value']);
    }
  }

  $query->filter($filter);
  if ($facets_only) {
    $query->range(0, 0);
  }

  $query->sort('search_api_id', 'ASC');
  $results = $query->execute();

  // Load events.
  if (!$facets_only) {
    $nids = array_keys($results['results']);
  }
  else {
    $nids = array();
  }

  // Process facets.
  $facets = array();
  if (isset($results['search_api_facets'])) {
    $term_fields = events_event_exported_term_fields();
    foreach ($results['search_api_facets'] as $key => $facet_info) {
      if (!array_key_exists($key, $term_fields)) {
        continue;
      }

      $facets[$term_fields[$key]['short_key']] = array(
        'label' => $term_fields[$key]['label'],
        'values' => array(),
      );
      $tids = array();
      foreach ($facet_info as $facet) {
        $tids[] = intval(str_replace('"', '', $facet['filter']));
      }

      $terms = taxonomy_term_load_multiple($tids);
      foreach ($terms as $term) {
        // Add parent.
        if ($term_fields[$key]['has_parents']) {
          if (isset($term->field_long_name[LANGUAGE_NONE][0]['value'])) {
            $facets[$term_fields[$key]['short_key']]['values'][$term->tid] = $term->field_long_name[LANGUAGE_NONE][0]['value'];
          }
          else {
            $facets[$term_fields[$key]['short_key']]['values'][$term->tid] = $term->name;
          }
        }
        else {
          $facets[$term_fields[$key]['short_key']]['values'][$term->tid] = $term->name;
        }
      }

      // Sort array.
      asort($facets[$term_fields[$key]['short_key']]['values']);
    }
  }

  return array(
    'facets' => $facets,
    'nids' => $nids,
  );
}

/**
 * Page callback for facets.
 */
function events_event_fetch_documents() {
}

/**
 * Page callback for events.
 */
function events_event_fetch_events() {
  $start = (isset($_GET['start']) && !empty($_GET['start'])) ? strtotime($_GET['start']) : strtotime('first day of this month', time());
  $end = (isset($_GET['end']) && !empty($_GET['end'])) ? strtotime($_GET['end']) : strtotime('last day of this month', time());
  if ($start > $end) {
    header('HTTP/1.1 400 Start date has to be smaller than end date.', TRUE, 400);
    module_invoke_all('exit');
    exit();
  }

  // Round to midnight.
  $start = $start - (60 * 60 * 24) - ($start % 86400);
  $end = $end + (60 * 60 * 24) - ($end % 86400);

  $query_filters = events_event_get_query_filters();
  $timezone = isset($_GET['timezone']) ? $_GET['timezone'] : drupal_get_user_timezone();

  $data = events_event_fetch_events_from_search_api($start, $end, $query_filters);
  $nids = array_flip($data['nids']);

  $events = array();

  // Load stored event data.
  if (!empty($nids)) {
    $result = db_select('events_event_data', 'e')
        ->fields('e', array('nid', 'data'))
        ->condition('nid', array_keys($nids), 'IN')
        ->execute()
        ->fetchAllKeyed(0, 1);

    foreach ($result as $nid => $events_data) {
      unset($nids[$nid]);
      $events_raw = unserialize($events_data);

      foreach ($events_raw as $event) {
        if ($timezone != 'UTC') {
          $date_start = new DateTime($event['start_raw'], timezone_open($event['timezone_db']));
          $date_start->setTimezone(timezone_open($timezone));
          $date_end = new DateTime($event['end_raw'], timezone_open($event['timezone_db']));
          $date_end->setTimezone(timezone_open($timezone));

          $event['start'] = $date_start->format(DATE_FORMAT_DATETIME);
          $event['end'] = $date_end->format(DATE_FORMAT_DATETIME);
        }

        unset($event['start_raw']);
        unset($event['end_raw']);
        unset($event['timezone_db']);
        unset($event['rrule']);
        unset($event['changed']);
        unset($event['created']);

        $events[] = $event;
      }
    }
  }

  // Check if data is missing.
  if (!empty($nids)) {
    $event_nodes = node_load_multiple(array_keys($nids));
    foreach ($event_nodes as $event_node) {
      $event_data = events_event_build_api_structure($event_node, $timezone);
      foreach ($event_data as $event) {
        unset($event['start_raw']);
        unset($event['end_raw']);
        unset($event['timezone_db']);
        unset($event['rrule']);
        unset($event['changed']);
        unset($event['created']);

        $events[] = $event;
      }
    }
  }

  events_event_json_output($events);
}

/**
 * Build data structure for API calls.
 */
function events_event_build_api_structure($node, $timezone = 'UTC') {
  $events = array();

  foreach ($node->field_event_date[LANGUAGE_NONE] as $date) {
    $date_start = new DateTime($date['value'], timezone_open($date['timezone_db']));
    $date_start->setTimezone(timezone_open($timezone));
    $date_end = new DateTime($date['value2'], timezone_open($date['timezone_db']));
    $date_end->setTimezone(timezone_open($timezone));

    $event = array(
      'start_raw' => $date['value'],
      'end_raw' => $date['value2'],
      'rrule' => $date['rrule'],
      'timezone_db' => $date['timezone_db'],
      'changed' => $node->changed,
      'created' => $node->created,
      'id' => $node->nid,
      'title' => $node->title,
      'start' => $date_start->format(DATE_FORMAT_DATETIME),
      'end' => $date_end->format(DATE_FORMAT_DATETIME),
      'allDay' => $date['value'] == $date['value2'],
      'url' => url('node/' . $node->nid, array('absolute' => TRUE)),
      'backgroundColor' => events_event_get_event_color($node),
      'location' => events_event_get_event_locations($node),
      'locationDetails' => isset($node->field_event_location_details[LANGUAGE_NONE][0]['value']) ? $node->field_event_location_details[LANGUAGE_NONE][0]['value'] : '',
      'description' => isset($node->field_event_info[LANGUAGE_NONE][0]['safe_value']) ? $node->field_event_info[LANGUAGE_NONE][0]['safe_value'] : '',
    );

    foreach (events_event_exported_term_fields() as $term_field => $term_field_info) {
      $event[$term_field_info['short_key']] = array();
      if (isset($node->{$term_field}[LANGUAGE_NONE][0]['tid'])) {
        foreach ($node->{$term_field}[LANGUAGE_NONE] as $child) {
          // Add parent tid.
          if ($term_field_info['has_parents']) {
            $term = taxonomy_term_load($child['tid']);
            $parents = explode('|', $term->field_parent_tids[LANGUAGE_NONE][0]['value']);
            foreach ($parents as $parent) {
              $event[$term_field_info['short_key']][] = $parent;
            }
          }
          else {
            $event[$term_field_info['short_key']][] = $child['tid'];
          }
        }
        $event[$term_field_info['short_key']] = array_unique($event[$term_field_info['short_key']]);
      }
      elseif (isset($term_field_info['node_field'])) {
        $document_types = events_event_document_types();
        $node_field = $term_field_info['node_field'];
        $multifield_field = $term_field_info['multifield_field'];
        if (isset($node->{$node_field}[LANGUAGE_NONE][0][$multifield_field][LANGUAGE_NONE])) {
          foreach ($node->{$node_field}[LANGUAGE_NONE][0][$multifield_field][LANGUAGE_NONE] as $key => $multifield) {
            $event[$term_field_info['short_key']][] = $multifield['tid'];
          }
          // Avoid duplicates.
          $event[$term_field_info['short_key']] = array_unique($event[$term_field_info['short_key']]);

          // Add documents.
          foreach ($node->{$node_field}[LANGUAGE_NONE][0]['field_document_file'][LANGUAGE_NONE] as $key => $multifield_file) {
            $event['files'][] = array(
              'uri' => file_create_url($multifield_file['uri'], array('absolute' => TRUE)),
              'name' => !empty($multifield_file['description']) ? $multifield_file['description'] : $multifield_file['origname'],
              'type' => $node->{$node_field}[LANGUAGE_NONE][0][$multifield_field][LANGUAGE_NONE][$key]['tid'],
              'type_human' => isset($node->{$node_field}[LANGUAGE_NONE][0][$multifield_field][LANGUAGE_NONE][$key]['tid']) ? $document_types[$node->{$node_field}[LANGUAGE_NONE][0][$multifield_field][LANGUAGE_NONE][$key]['tid']]['name'] : '',
            );
          }
        }
      }
    }
    $events[] = $event;
  }
  return $events;
}

/**
 * Page callback for ical.
 */
function events_event_to_ical() {
  $query_filters = events_event_get_query_filters();
  $data = events_event_fetch_events_from_search_api('', '', $query_filters);
  $nids = array_flip($data['nids']);

  $events = array();

  // Load stored event data.
  if (!empty($nids)) {
    $result = db_select('events_event_data', 'e')
        ->fields('e', array('nid', 'data'))
        ->condition('nid', array_keys($nids), 'IN')
        ->execute()
        ->fetchAllKeyed(0, 1);

    foreach ($result as $nid => $events_data) {
      unset($nids[$nid]);
      $events[] = unserialize($events_data);
    }
  }

  // Check if data is missing.
  if (!empty($nids)) {
    $event_nodes = node_load_multiple(array_keys($nids));
    foreach ($event_nodes as $event_node) {
      $event_data = events_event_build_api_structure($event_node, $timezone);
      $events[] = $event_data;
    }
  }

  $library = libraries_load('iCalcreator');
  $config = array('unique_id' => 'Date iCal');
  $vcalendar = new vcalendar($config);
  $vcalendar->setMethod('PUBLISH');
  $vcalendar->setProperty('X-WR-CALNAME', 'UN Events', array('VALUE' => 'TEXT'));
  $vcalendar->setProperty('X-WR-TIMEZONE', 'UTC');

  foreach ($events as $event) {
    $node = $event[0];
    $date = array(
      'value' => $node['start_raw'],
      'value2' => $node['end_raw'],
      'rrule' => $node['rrule'],
    );
    $vevent = $vcalendar->newComponent('vevent');
    $vevent->setUid($node->nid);
    $vevent->setSummary($node->title);

    $date_start = new DateTime($date['value']);

    if ($date['value'] == $date['value2']) {
      $vevent->setDtstart(
        $date_start->format('Y'),
        $date_start->format('m'),
        $date_start->format('d'),
        FALSE,
        FALSE,
        FALSE,
        FALSE,
        array('VALUE' => 'DATE')
      );
    }
    else {
      $vevent->setDtstart(
        $date_start->format('Y'),
        $date_start->format('m'),
        $date_start->format('d'),
        $date_start->format('H'),
        $date_start->format('i'),
        $date_start->format('s'),
        'UTC'
      );
    }

    // Only add the end date if there is one.
    if (!empty($date['value2'])) {
      $date_end = new DateTime($date['value2']);

      if ($date['value'] == $date['value2']) {
        $vevent->setDtend(
          $date_end->format('Y'),
          $date_end->format('m'),
          $date_end->format('d'),
          FALSE,
          FALSE,
          FALSE,
          FALSE,
          array('VALUE' => 'DATE')
        );
      }
      else {
        $vevent->setDtend(
          $date_end->format('Y'),
          $date_end->format('m'),
          $date_end->format('d'),
          $date_end->format('H'),
          $date_end->format('i'),
          $date_end->format('s'),
          'UTC'
        );
      }
    }

    // Handle repeating dates from the date_repeat module.
    if (!empty($date['rrule']) && module_exists('date_repeat')) {
      // Split the rrule into an RRULE and any additions and exceptions.
      module_load_include('inc', 'date_api', 'date_api_ical');
      module_load_include('inc', 'date_repeat', 'date_repeat_calc');
      list($rrule, $exceptions, $additions) = date_repeat_split_rrule($date['rrule']);

      // Add the RRULE itself.
      $vevent->setRrule(_date_ical_convert_rrule_for_icalcreator($rrule));

      // Convert any exceptions to EXDATE properties.
      if (!empty($exceptions)) {
        $exdates = array();
        foreach ($exceptions as $exception) {
          $except = date_ical_date($exception, 'UTC');
          $except->setTimezone('UTC');
          $exception_array = $except->toArray();
          $exdates[] = array(
            'year' => $exception_array['year'],
            'month' => $exception_array['month'],
            'day' => $exception_array['day'],
            'hour' => $date_start->format('H'),
            'min' => $date_start->format('i'),
            'second' => $date_start->format('s'),
            'tz' => 'UTC',
          );
        }
        foreach ($exdates as $exdate) {
          $vevent->setExdate(array($exdate));
        }
      }

      // Convert any additions to RDATE properties.
      if (!empty($additions)) {
        $rdates = array();
        foreach ($additions as $addition) {
          $add = date_ical_date($addition, 'UTC');
          $add->setTimezone('UTC');
          $addition_array = $add->toArray();

          $rdate = array(
            'year' => $addition_array['year'],
            'month' => $addition_array['month'],
            'day' => $addition_array['day'],
            'hour' => !empty($addition_array['hour']) ? $addition_array['hour'] : $date_start->format('H'),
            'min' => !empty($addition_array['minute']) ? $addition_array['minute'] : $date_start->format('i'),
            'second' => !empty($addition_array['second']) ? $addition_array['second'] : $date_start->format('s'),
            'tz' => 'UTC',
          );

          // If an end date was was calculated above, use that too.
          if (!empty($date['value2'])) {
            $rdate_with_end = array($rdate);
            $rdate_with_end[] = array(
              'year' => $addition_array['year'],
              'month' => $addition_array['month'],
              'day' => $addition_array['day'],
              'hour' => !empty($addition_array['hour']) ? $addition_array['hour'] : $date_end->format('H'),
              'min' => !empty($addition_array['minute']) ? $addition_array['minute'] : $date_end->format('i'),
              'second' => !empty($addition_array['second']) ? $addition_array['second'] : $date_end->format('s'),
              'tz' => 'UTC',
            );
            $rdate = $rdate_with_end;
          }

          $rdates[] = $rdate;
        }

        foreach ($rdates as $rdate) {
          $vevent->setRdate(array($rdate));
        }
      }
    }

    $vevent->setUrl($node['url']);
    $vevent->setDescription($node['title']);

    // Last modified - updated.
    $lm = new DateTime();
    $lm->setTimestamp($node['changed']);
    $vevent->setLastModified(
      $lm->format('Y'),
      $lm->format('m'),
      $lm->format('d'),
      $lm->format('H'),
      $lm->format('i'),
      $lm->format('s'),
      'UTC'
    );

    // Created.
    $lm = new DateTime();
    $lm->setTimestamp($node['created']);
    $vevent->setCreated(
      $lm->format('Y'),
      $lm->format('m'),
      $lm->format('d'),
      $lm->format('H'),
      $lm->format('i'),
      $lm->format('s'),
      'UTC'
    );
  }

  $output = $vcalendar->createCalendar();

  // Prevent devel module from appending queries to ical export.
  $GLOBALS['devel_shutdown'] = FALSE;

  drupal_add_http_header('Content-Type', 'text/calendar; charset=UTF-8');
  drupal_add_http_header('Expires', 'Sat, 26 Jul 1997 05:00:00 GMT');
  if (variable_get('events_event_page_cache', 60)) {
    drupal_add_http_header('Cache-Control', 'public, max-age=' . variable_get('events_event_page_cache', 60));
  }

  echo $output;
}

/**
 * Page callback for organisations.
 */
function events_event_fetch_organisations() {
  $cache_key = 'events_event:organisations';

  $cache = cache_get($cache_key);
  if ($cache && !empty($cache->data)) {
    events_event_json_output($cache->data);
    return;
  }

  $organisations = array();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'ev_organization')
    ->execute();

  if (isset($result['taxonomy_term'])) {
    $tids = array_keys($result['taxonomy_term']);
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
      $organisations[] = array(
        'tid' => $term->tid,
        'name' => $term->name,
      );
    }
  }

  cache_set($cache_key, $organisations);
  events_event_json_output($organisations);
}

/**
 * Page callback for clusters.
 */
function events_event_fetch_clusters() {
  $cache_key = 'events_event:clusters';

  $cache = cache_get($cache_key);
  if ($cache && !empty($cache->data)) {
    events_event_json_output($cache->data);
    return;
  }

  $clusters = array();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'ev_list')
    ->execute();

  if (isset($result['taxonomy_term'])) {
    $tids = array_keys($result['taxonomy_term']);
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
      $clusters[] = array(
        'tid' => $term->tid,
        'name' => $term->name,
      );
    }
  }

  cache_set($cache_key, $clusters);
  events_event_json_output($clusters);
}

/**
 * Page callback for locations.
 */
function events_event_fetch_locations() {
  $cache_key = 'events_event:locations';

  $cache = cache_get($cache_key);
  if ($cache && !empty($cache->data)) {
    events_event_json_output($cache->data);
    return;
  }

  $locations = array();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'ev_location')
    ->execute();

  if (isset($result['taxonomy_term'])) {
    $tids = array_keys($result['taxonomy_term']);
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
      $locations[] = array(
        'tid' => $term->tid,
        'name' => $term->name,
      );
    }
  }

  cache_set($cache_key, $locations);
  events_event_json_output($locations);
}

/**
 * Page callback for countries.
 */
function events_event_fetch_countries() {
  $cache_key = 'events_event:countries';

  $cache = cache_get($cache_key);
  if ($cache && !empty($cache->data)) {
    events_event_json_output($cache->data);
    return;
  }

  $countries = array();
  $vocabularies = taxonomy_vocabulary_get_names();
  $vid = $vocabularies['ev_location']->vid;

  $query = db_query('select td.tid from {taxonomy_term_data} td left join {taxonomy_term_hierarchy} th on td.tid = th.tid where vid = :vid AND parent = 0;', array(
    ':vid' => $vid,
  ));
  $result = $query->fetchAllKeyed(0, 0);

  if ($result) {
    $terms = taxonomy_term_load_multiple($result);
    foreach ($terms as $term) {
      $countries[] = array(
        'tid' => $term->tid,
        'name' => $term->name,
      );
    }
  }

  cache_set($cache_key, $countries);
  events_event_json_output($countries);
}

/**
 * Page callback for disasters.
 */
function events_event_fetch_disasters() {
  $cache_key = 'events_event:disasters';

  $cache = cache_get($cache_key);
  if ($cache && !empty($cache->data)) {
    events_event_json_output($cache->data);
    return;
  }

  $disasters = array();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'ev_disaster')
    ->execute();

  if (isset($result['taxonomy_term'])) {
    $tids = array_keys($result['taxonomy_term']);
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
      $disasters[] = array(
        'tid' => $term->tid,
        'name' => $term->name,
      );
    }
  }

  cache_set($cache_key, $disasters);
  events_event_json_output($disasters);
}

/**
 * Page callback for themes.
 */
function events_event_fetch_themes() {
  $cache_key = 'events_event:themes';

  $cache = cache_get($cache_key);
  if ($cache && !empty($cache->data)) {
    events_event_json_output($cache->data);
    return;
  }

  $themes = array();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'ev_theme')
    ->execute();

  if (isset($result['taxonomy_term'])) {
    $tids = array_keys($result['taxonomy_term']);
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
      $themes[] = array(
        'tid' => $term->tid,
        'name' => $term->name,
      );
    }
  }

  cache_set($cache_key, $themes);
  events_event_json_output($themes);
}

/**
 * Page callback for categories.
 */
function events_event_fetch_categories() {
  $categories = _events_event_fetch_categories();
  events_event_json_output($categories);
}

/**
 * Build list of categories.
 */
function _events_event_fetch_categories() {
  $cache_key = 'events_event:categories';

  $cache = cache_get($cache_key);
  if ($cache && !empty($cache->data)) {
    return $cache->data;
  }

  $categories = array();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'ev_category')
    ->execute();

  if (isset($result['taxonomy_term'])) {
    $tids = array_keys($result['taxonomy_term']);
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
      $categories[] = array(
        'tid' => $term->tid,
        'name' => $term->name,
        'color' => isset($term->field_ev_legend_color[LANGUAGE_NONE][0]['rgb']) ? $term->field_ev_legend_color[LANGUAGE_NONE][0]['rgb'] : '',
      );
    }
  }

  cache_set($cache_key, $categories);
  return $categories;
}

/**
 * Page callback for facets.
 */
function events_event_fetch_facets() {
  $start = (isset($_GET['start']) && !empty($_GET['start'])) ? strtotime($_GET['start']) : '';
  $end = (isset($_GET['end']) && !empty($_GET['end'])) ? strtotime($_GET['end']) : '';
  if ($start > $end) {
    header('HTTP/1.1 400 Start date has to be smaller than end date.', TRUE, 400);
    module_invoke_all('exit');
    exit();
  }

  $query_filters = events_event_get_query_filters();
  $data = events_event_fetch_events_from_search_api($start, $end, $query_filters, TRUE);
  $facets = $data['facets'];

  events_event_json_output($facets);
}

/**
 * Page callback for time zones.
 */
function events_event_fetch_timezones() {
  events_event_json_output(events_event_system_time_zones());
}

/**
 * Custom implementation of system_time_zones.
 *
 * @see system_time_zones()
 */
function events_event_system_time_zones() {
  // @codingStandardsIgnoreStart
  $zonelist = timezone_identifiers_list();
  $timezones = array();
  foreach ($zonelist as $zone) {
    if (preg_match('!^((Africa|America|Antarctica|Arctic|Asia|Atlantic|Australia|Europe|Indian|Pacific)/|UTC$)!', $zone)) {
      $timezones[$zone] = t('@zone: @date', array(
        '@zone' => t(str_replace(array('_', '/'), array(' ', ' - '), $zone)),
        '@date' => format_date(REQUEST_TIME, 'custom', 'l d F Y - H:i' . ' O', $zone),
      ), array('context' => 'events'));
    }
  }
  // Sort the translated time zones alphabetically.
  asort($timezones);
  // @codingStandardsIgnoreEnd

  return $timezones;
}

/**
 * Implements hook_taxonomy_term_presave().
 */
function events_event_taxonomy_term_presave($term) {
  if (isset($term->vocabulary_machine_name) && $term->vocabulary_machine_name == 'ev_location') {
    // Get original parent for existing terms.
    if (isset($term->tid)) {
      $query = db_select('taxonomy_term_data', 't');
      $query->join('taxonomy_term_hierarchy', 'h', 'h.parent = t.tid');
      $query->addField('t', 'tid');
      $query->condition('h.tid', $term->tid);
      $query->orderBy('t.weight');
      $query->orderBy('t.name');
      $tids = $query->execute()->fetchCol();

      $parent_ids = taxonomy_term_load_multiple($tids);
      $parent_ids = array_keys($parent_ids);
      $parent_id = reset($parent_ids);
    }
    else {
      $parent_id = 0;
    }

    // Make sure we have a parent.
    if (!isset($term->parent)) {
      $term_parent_id = $parent_id;
    }
    else {
      if (is_array($term->parent)) {
        $term_parent_id = reset($term->parent);
      }
      else {
        $term_parent_id = $term->parent;
      }
    }

    // Update long name based on direct child if needed.
    if (!isset($term->field_long_name[LANGUAGE_NONE][0]['value']) || empty($term->field_long_name[LANGUAGE_NONE][0]['value']) || $parent_id != $term_parent_id) {
      if ($term_parent_id == 0) {
        $term->field_long_name[LANGUAGE_NONE][0]['value'] = $term->name;
      }
      else {
        if ($parent_id) {
          $parent = taxonomy_term_load($parent_id);
        }
        elseif ($term_parent_id) {
          $parent = taxonomy_term_load($term_parent_id);
        }
        $term->field_long_name[LANGUAGE_NONE][0]['value'] = $parent->field_long_name[LANGUAGE_NONE][0]['value'] . ' > ' . $term->name;
      }
    }

    // Update parent tids based on direct child if needed.
    if (!empty($term->tid)) {
      if (!isset($term->field_parent_tids[LANGUAGE_NONE][0]['value']) || empty($term->field_parent_tids[LANGUAGE_NONE][0]['value']) || $parent_id != $term_parent_id) {
        if ($term_parent_id == 0) {
          $term->field_parent_tids[LANGUAGE_NONE][0]['value'] = $term->tid;
        }
        else {
          if ($parent_id) {
            $parent = taxonomy_term_load($parent_id);
          }
          elseif ($term_parent_id) {
            $parent = taxonomy_term_load($term_parent_id);
          }
          $term->field_parent_tids[LANGUAGE_NONE][0]['value'] = $parent->field_parent_tids[LANGUAGE_NONE][0]['value'] . '|' . $term->tid;
        }
      }
    }
  }
}

/**
 * Implements hook_taxonomy_term_update().
 */
function events_event_taxonomy_term_update($term) {
  events_event_clear_term_cache($term);
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function events_event_taxonomy_term_insert($term) {
  // Update parent tids based on direct child if needed.
  if (isset($term->vocabulary_machine_name) && $term->vocabulary_machine_name == 'ev_location') {
    if (!isset($term->field_parent_tids[LANGUAGE_NONE][0]['value']) || empty($term->field_parent_tids[LANGUAGE_NONE][0]['value'])) {
      // Trigger an update.
      taxonomy_term_save($term);
      return;
    }
  }

  events_event_clear_term_cache($term);
}

/**
 * Clear term cache.
 */
function events_event_clear_term_cache($term) {
  // Do not clear the cache during cron.
  if (variable_get('cron_semaphore', FALSE)) {
    return;
  }

  if (isset($term->vocabulary_machine_name)) {
    switch ($term->vocabulary_machine_name) {
      case 'ev_organization':
        cache_clear_all('events_event:organisations', 'cache');
        break;

      case 'ev_list':
        cache_clear_all('events_event:clusters', 'cache');
        break;

      case 'ev_category':
        cache_clear_all('events_event:categories', 'cache');
        break;

      case 'ev_location':
        cache_clear_all('events_event:locations', 'cache');
        cache_clear_all('events_event:edit-locations', 'cache');
        break;

      case 'ev_disaster':
        cache_clear_all('events_event:disasters', 'cache');
        break;

    }
  }
}

/**
 * Get locations of an event as string.
 */
function events_event_get_event_locations($node) {
  $output = '';

  if (isset($node->field_event_location[LANGUAGE_NONE])) {
    $tids = array();
    foreach ($node->field_event_location[LANGUAGE_NONE] as $location) {
      $tids[] = $location['tid'];
    }
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
      $output[] = $term->name;
    }

    $output = implode(', ', $output);
  }

  return $output;
}

/**
 * Create a stripe based on a taxonomy term.
 */
function events_event_get_event_color($node) {
  $term_field_name = 'field_event_category';
  if ($terms_for_entity = field_get_items('node', $node, $term_field_name)) {
    foreach ($terms_for_entity as $delta => $item) {
      $term_for_entity = taxonomy_term_load($item['tid']);
      if ($term_for_entity) {
        if (isset($term_for_entity->field_ev_legend_color[LANGUAGE_NONE][0]['rgb'])) {
          return $term_for_entity->field_ev_legend_color[LANGUAGE_NONE][0]['rgb'];
        }
        else {
          return sprintf('#%06X', mt_rand(0, 0xFFFFFF));
        }
      }
    }
  }
}

/**
 * Implements hook_js_alter().
 */
function events_event_js_alter(&$javascript) {
  // Remove fullcalendar javascript.
  if (isset($javascript['sites/all/modules/contrib/fullcalendar_api/fullcalendar_calendar.js'])) {
    unset($javascript['sites/all/modules/contrib/fullcalendar_api/fullcalendar_calendar.js']);
  }
}

/**
 * Implements hook_date_timezone_process_alter().
 */
function events_event_date_timezone_process_alter(&$element, &$form_state, $context) {
  $element['timezone']['#options'] = events_event_system_time_zones();
}

/**
 * Implements hook_field_extra_fields().
 */
function events_event_field_extra_fields() {
  $extra['node']['ev_event']['display']['ev_local_time'] = array(
    'label' => t('Display date in local time', array(), array('context' => 'events')),
    'description' => t('Display date in local time (as entered by the user).', array(), array('context' => 'events')),
    'weight' => 2,
  );
  $extra['node']['ev_event']['display']['ev_user_time'] = array(
    'label' => t('Display date in user time', array(), array('context' => 'events')),
    'description' => t('Display date in user time (as defined on profile).', array(), array('context' => 'events')),
    'weight' => 2,
  );
  $extra['node']['ev_event']['display']['ev_display_date_time'] = array(
    'label' => t('Display date in user and local time', array(), array('context' => 'events')),
    'description' => t('Display datein user (as defined on profile) and local time  (as entered by the user).', array(), array('context' => 'events')),
    'weight' => 2,
  );
  $extra['node']['ev_event']['display']['ev_page_heading'] = array(
    'label' => t('Display date and title in heading', array(), array('context' => 'events')),
    'description' => t('Display date and event title in page heading.', array(), array('context' => 'events')),
    'weight' => 2,
  );

  return $extra;
}

/**
 * Implements hook_node_view().
 */
function events_event_node_view($node, $view_mode, $langcode) {
  $extrafields = field_extra_fields_get_display('node', $node->type, $view_mode);

  $extrafield_name = 'ev_local_time';
  if (isset($extrafields[$extrafield_name])
      && isset($extrafields[$extrafield_name]['visible'])
      && $extrafields[$extrafield_name]['visible']) {
    $node->content[$extrafield_name] = _events_event_ev_local_time($node, $view_mode, $langcode);
  }

  $extrafield_name = 'ev_user_time';
  if (isset($extrafields[$extrafield_name])
      && isset($extrafields[$extrafield_name]['visible'])
      && $extrafields[$extrafield_name]['visible']) {
    $node->content[$extrafield_name] = _events_event_ev_user_time($node, $view_mode, $langcode);
  }

  $extrafield_name = 'ev_display_date_time';
  if (isset($extrafields[$extrafield_name])
      && isset($extrafields[$extrafield_name]['visible'])
      && $extrafields[$extrafield_name]['visible']) {
    $node->content[$extrafield_name] = _events_event_ev_display_date_time($node, $view_mode, $langcode);
  }

  $extrafield_name = 'ev_page_heading';
  if (isset($extrafields[$extrafield_name])
      && isset($extrafields[$extrafield_name]['visible'])
      && $extrafields[$extrafield_name]['visible']) {
    $node->content[$extrafield_name] = _events_event_ev_page_heading($node, $view_mode, $langcode);
  }
}

/**
 * Display date in page heading.
 */
function _events_event_ev_page_heading($node, $view_mode, $langcode) {
  $date = $node->field_event_date[LANGUAGE_NONE][0];
  $date_start = new DateTime($date['value'], timezone_open($date['timezone_db']));
  $date_start->setTimezone(timezone_open(drupal_get_user_timezone()));

  $dates = array(
    'show_remaining_days' => FALSE,
    'value' => array(
      'formatted' => $date_start->format('d F Y H:i'),
      'formatted_date' => $date_start->format('d F Y'),
      'formatted_time' => $date_start->format('H:i'),
      'formatted_timezone' => drupal_get_user_timezone(),
    ),
  );

  $output = $dates['value']['formatted_date'];

  return array(
    '#markup' => '<h1 class="event-heading"><span>' . $output . '</span> ' . $node->title . '</h1>',
  );
}

/**
 * Display date in user and local time.
 */
function _events_event_ev_display_date_time($node, $view_mode, $langcode) {
  $local = _events_event_ev_local_time($node, $view_mode, $langcode);
  $user = _events_event_ev_user_time($node, $view_mode, $langcode);
  $local_html = '<p><strong>' . t('Local time', array(), array('context' => 'events')) . ':</strong><br>' . $local . '</p>';
  $user_html = '<p><strong>' . t('Your time', array(), array('context' => 'events')) . ':</strong><br>' . $user . '</p>';

  return array(
    '#markup' => '<div class="field field-type-date field-type-date-user"><div class="field-label">' . t('Date & time', array(), array('context' => 'events')) . ' </div><div class="field-items">' . $local_html . $user_html . '</div></div>',
  );

}

/**
 * Display date in local time.
 */
function _events_event_ev_local_time($node, $view_mode, $langcode) {
  $date = $node->field_event_date[LANGUAGE_NONE][0];
  $date_start = new DateTime($date['value'], timezone_open($date['timezone_db']));
  $date_start->setTimezone(timezone_open($date['timezone']));
  $date_end = new DateTime($date['value2'], timezone_open($date['timezone_db']));
  $date_end->setTimezone(timezone_open($date['timezone']));

  $dates = array(
    'show_remaining_days' => FALSE,
    'value' => array(
      'formatted' => $date_start->format('d F Y H:i'),
      'formatted_date' => $date_start->format('d F Y'),
      'formatted_time' => $date_start->format('H:i'),
      'formatted_timezone' => $date['timezone'],
    ),
    'value2' => array(
      'formatted' => $date_end->format('d F Y H:i'),
      'formatted_date' => $date_end->format('d F Y'),
      'formatted_time' => $date_end->format('H:i'),
      'formatted_timezone' => $date['timezone'],
    ),
  );

  $output = _events_event_render_dates_as_string($dates);
  return $output;
}

/**
 * Display date in user time.
 */
function _events_event_ev_user_time($node, $view_mode, $langcode) {
  $date = $node->field_event_date[LANGUAGE_NONE][0];
  $date_start = new DateTime($date['value'], timezone_open($date['timezone_db']));
  $date_start->setTimezone(timezone_open(drupal_get_user_timezone()));
  $date_end = new DateTime($date['value2'], timezone_open($date['timezone_db']));
  $date_end->setTimezone(timezone_open(drupal_get_user_timezone()));

  $dates = array(
    'show_remaining_days' => FALSE,
    'value' => array(
      'formatted' => $date_start->format('d F Y H:i'),
      'formatted_date' => $date_start->format('d F Y'),
      'formatted_time' => $date_start->format('H:i'),
      'formatted_timezone' => drupal_get_user_timezone(),
    ),
    'value2' => array(
      'formatted' => $date_end->format('d F Y H:i'),
      'formatted_date' => $date_end->format('d F Y'),
      'formatted_time' => $date_end->format('H:i'),
      'formatted_timezone' => drupal_get_user_timezone(),
    ),
  );

  $output = _events_event_render_dates_as_string($dates);
  return $output;
}

/**
 * Render dates as a string.
 */
function _events_event_render_dates_as_string($dates) {
  $output = '';

  $date1 = $dates['value']['formatted'];
  $date2 = $dates['value2']['formatted'];

  $timezone = $dates['value']['formatted_timezone'];
  $date1 = str_replace($timezone, '', $date1);
  $date2 = str_replace($timezone, '', $date2);
  $time1 = preg_replace('`^([\(\[])`', '', $dates['value']['formatted_time']);
  $time1 = preg_replace('([\)\]]$)', '', $time1);
  $time2 = preg_replace('`^([\(\[])`', '', $dates['value2']['formatted_time']);
  $time2 = preg_replace('([\)\]]$)', '', $time2);

  if ($date1 == $date2 || empty($date2)) {
    $output .= theme('date_display_single', array(
      'date' => $date1,
      'timezone' => ' (' . $timezone . ')',
      'attributes' => array(),
      'rdf_mapping' => array(),
      'add_rdf' => FALSE,
      'microdata' => array(),
      'add_microdata' => FALSE,
      'dates' => $dates,
      'show_remaining_days' => FALSE,
    ));
  }
  elseif ($dates['value']['formatted_date'] == $dates['value2']['formatted_date']) {
    $time = theme('date_display_range', array(
      'date1' => $time1,
      'date2' => $time2,
      'timezone' => ' (' . $timezone . ')',
      'attributes' => array(),
      'rdf_mapping' => array(),
      'add_rdf' => FALSE,
      'microdata' => array(),
      'add_microdata' => FALSE,
      'dates' => $dates,
      'show_remaining_days' => FALSE,
    ));
    $replaced = str_replace($time1, $time, $date1);
    $output .= theme('date_display_single', array(
      'date' => $replaced,
      'timezone' => '',
      'attributes' => array(),
      'rdf_mapping' => array(),
      'add_rdf' => FALSE,
      'dates' => $dates,
    ));
  }
  else {
    $output .= theme('date_display_range', array(
      'date1' => $date1,
      'date2' => $date2,
      'timezone' => ' (' . $timezone . ')',
      'attributes' => array(),
      'rdf_mapping' => array(),
      'add_rdf' => FALSE,
      'microdata' => array(),
      'add_microdata' => FALSE,
      'dates' => $dates,
      'show_remaining_days' => FALSE,
    ));
  }

  return $output;
}

/**
 * Output as JSON.
 */
function events_event_json_output($data) {
  drupal_add_http_header('Access-Control-Allow-Origin', '*');
  drupal_add_http_header('Access-Control-Allow-Methods', 'GET');
  if (variable_get('events_event_page_cache', 60)) {
    drupal_add_http_header('Cache-Control', 'public, max-age=' . variable_get('events_event_page_cache', 60));
  }
  drupal_json_output($data);
}

/**
 * Get query filters.
 */
function events_event_get_query_filters() {
  $query_filters = array();
  $term_fields = events_event_exported_term_fields();
  foreach ($term_fields as $term_field => $term_field_info) {
    $query_filters[$term_field] = array(
      'value' => isset($_GET[$term_field]) ? $_GET[$term_field] : (isset($_GET[$term_field_info['short_key']]) ? $_GET[$term_field_info['short_key']] : ''),
      'forced' => FALSE,
    );
    if (!empty($query_filters[$term_field]['value'])) {
      if (!is_numeric($query_filters[$term_field]['value'])) {
        header('HTTP/1.1 400 ' . $query_filters[$term_field]['value'] . ' is an integer.', TRUE, 400);
        module_invoke_all('exit');
        exit();
      }
    }

    // Value key overrules normal keys.
    if (isset($term_field_info['value_key']) && isset($_GET[$term_field_info['value_key']])) {
      $query = new EntityFieldQuery();
      $result = $query
        ->entityCondition('entity_type', 'taxonomy_term')
        ->entityCondition('bundle', $term_field_info['bundle'])
        ->propertyCondition('name', '%' . check_plain($_GET[$term_field_info['value_key']]) . '%', 'LIKE')
        ->execute();

      if (isset($result['taxonomy_term'])) {
        $tids = array_keys($result['taxonomy_term']);
        $query_filters[$term_field] = array(
          'value' => (string) reset($tids),
          'forced' => TRUE,
        );
      }
    }
  }

  return $query_filters;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 */
function events_event_field_widget_form_alter(&$element, &$form_state, $context) {
  if (isset($element['#options']) && $element['#field_name'] == 'field_event_location') {
    $cache_key = 'events_event:edit-locations';

    $cache = cache_get($cache_key);
    if ($cache && !empty($cache->data)) {
      $element['#options'] = $cache->data;
      return;
    }

    $ids = array_keys($element['#options']);
    $terms = taxonomy_term_load_multiple($ids);

    foreach ($element['#options'] as $tid => &$option) {
      if (is_numeric($tid)) {
        $option_label = array();
        if (isset($terms[$tid]->field_long_name[LANGUAGE_NONE][0]['value'])) {
          $option = $terms[$tid]->field_long_name[LANGUAGE_NONE][0]['value'];
        }
      }
    }
    cache_set($cache_key, $element['#options']);
  }
}

/**
 * List of document types.
 */
function events_event_document_types() {
  $document_types = array();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'ev_document_type')
    ->execute();

  if (isset($result['taxonomy_term'])) {
    $tids = array_keys($result['taxonomy_term']);
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
      $document_types[$term->tid] = array(
        'tid' => $term->tid,
        'name' => $term->name,
      );
    }
  }

  return $document_types;
}

/**
 * Add default terms for categoy.
 */
function _events_event_default_terms() {
  $field_instance = field_info_instance('node', 'field_event_category', 'ev_event');
  if (!$field_instance) {
    return;
  }

  // Create terms for document type.
  events_config_get_term('Agenda', 'ev_document_type');
  events_config_get_term('Meeting Minutes', 'ev_document_type');
  events_config_get_term('Presentation', 'ev_document_type');

  // Create terms for category.
  events_config_get_term('Conference', 'ev_category');
  events_config_get_term('Meeting', 'ev_category');
  events_config_get_term('Training', 'ev_category');
  events_config_get_term('Workshop', 'ev_category');

  // Set default to Meeting for category field.
  $default = events_config_get_term('Meeting', 'ev_category');
  $field_instance['default_value'][0]['tid'] = $default['term']->tid;
  field_update_instance($field_instance);
}

/**
 * Implements hook_features_post_restore().
 */
function events_event_features_post_restore($op, $items) {
  // Rebuild search api tables.
  if ($op == 'revert' || $op == 'enable') {
    $index = search_api_index_load('un_events');
    $index->server()->fieldsUpdated($index);
    $index->queueItems();
  }

  // Default terms.
  if ($op == 'revert' || $op == 'enable') {
    _events_event_default_terms();
  }
}

/**
 * Implements hook_node_presave().
 */
function events_event_node_presave($node) {
  if (!$node->is_new && $node->type == 'ev_event') {
    global $user;
    if ($node->uid == $user->uid) {
      return;
    }

    // Enable revisions.
    $node->revision = TRUE;
    if (empty($node->log)) {
      $node->log = t('Event updated by IMO', array(), array('context' => 'events'));
    }
    else {
      $node->log .= "\n\n" . t('Event updated by IMO', array(), array('context' => 'events'));
    }
  }
}

/**
 * Implements hook_node_update().
 */
function events_event_node_update($node) {
  if (!$node->is_new && $node->type == 'ev_event') {
    global $user;
    if ($node->uid == $user->uid) {
      return;
    }

    $recipient = user_load($node->uid);

    $date_start = new DateTime($node->field_event_date[LANGUAGE_NONE][0]['value'], timezone_open($node->field_event_date[LANGUAGE_NONE][0]['timezone_db']));
    $date_end = new DateTime($node->field_event_date[LANGUAGE_NONE][0]['value2'], timezone_open($node->field_event_date[LANGUAGE_NONE][0]['timezone_db']));

    // Sent email.
    $subject = t('Your Event was Edited', array(), array('context' => 'events'));
    $body = t('Dear @user_name,

We wanted to let you know that your event has been updated by @user_edit.

The new event details are as follows:

@node_title

@node_field_event_info

Start: @node_field_event_date_value_start
Finish: @node_field_event_date_value_end
Timezone: @node_field_event_date_tz

Please review the complete event details and make sure they are correct.

Event page: @node_url

--
Humanitarian Events
A service powered by OCHA
https://events.rwlabs.org

    ', array(
      '@user_name' => $recipient->name,
      '@user_edit' => $user->name,
      '@node_title' => $node->title,
      '@node_field_event_info' => isset($node->field_event_info[LANGUAGE_NONE][0]['value']) ? $node->field_event_info[LANGUAGE_NONE][0]['value'] : '',
      '@node_field_event_date_value_start' => $date_start->format('l d F Y - H:i'),
      '@node_field_event_date_value_end' => $date_end->format('l d F Y - H:i'),
      '@node_field_event_date_tz' => $node->field_event_date[LANGUAGE_NONE][0]['timezone_db'],
      '@node_url' => url('node/' . $node->nid, array('absolute' => TRUE)),
    ), array('context' => 'events'));

    $context = array(
      'recipient' => $recipient->mail,
      'subject' => $subject,
      'message' => $body,
      'node' => $node,
      'user' => $user,
    );

    system_send_email_action($node, $context);
  }
}

/**
 * Implements hook_search_api_alter_callback_info().
 */
function events_event_search_api_alter_callback_info() {
  // This does not work with search_api_db, no field are returned.
  $callbacks['events_event_search_api_store_data'] = array(
    'name' => t('Store data for events API calls'),
    'description' => t('Store data for events API calls.'),
    'class' => 'EventsEventSearchApiStoreData',
    'weight' => 100,
  );

  return $callbacks;
}
