<?php
/**
 * @file
 * Code for the Event feature.
 */

include_once 'events_event.features.inc';

/**
 * Implements hook_menu().
 */
function events_event_menu() {
  $items['calendar'] = array(
    'title' => 'Calendar',
    'page callback' => 'events_event_calendar',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['fetch-events'] = array(
    'title' => 'Fetch events',
    'page callback' => 'events_event_fetch_events',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Page callback for calendar.
 */
function events_event_calendar() {
  $settings = array(
    'header' => array(
      'left' => 'prev,next today',
      'center' => 'title',
      'right' => 'month,agendaWeek,agendaDay,listYear',
    ),
    'editable' => FALSE,
    'eventLimit' => TRUE,
    'events' => 'fetch-events',
    'firstDay' => 1,
    'weekends' => FALSE,
    'data' => array(
      'org' => 'something',
      'list' => 'somethingelse',
    ),
  );

  return theme('fullcalendar_calendar', array(
    'calendar_id' => 'fullcalendar',
    'calendar_settings' => $settings,
  ));
}

/**
 * Page callback for /fullcalendar/calendar.
 */
function events_event_fetch_events() {
  $start = $_GET['start'];
  $end = $_GET['end'];

  $index = search_api_index_load("un_events");
  $query = new SearchApiQuery($index);

  $filter = $query->createFilter('AND');
  $filter->condition('field_event_date:value', strtotime($start), '>=');
  $filter->condition('field_event_date:value', strtotime($end), '<=');
  $query->filter($filter);
  // Fetch results.
  $results = $query->execute()['results'];
  $nids = array_keys($results);
  $nodes = node_load_multiple($nids);
  $events = array();
  foreach ($nodes as $node) {
    foreach ($node->field_event_date['und'] as $date) {
      $events[] = array(
        'id' => $node->nid,
        'title' => $node->title,
        'start' => $date['value'],
        'end' => $date['value2'],
        'allDay' => $date['value'] == $date['value2'],
        'url' => url('node/' . $node->nid),
        'className' => 'org-' . $node->field_event_organization['und'][0]['tid'],
        'backgroundColor' => events_event_get_event_color($node),
      );
    }
  }
  drupal_json_output($events);
}

/**
 * Create a stripe based on a taxonomy term.
 */
function events_event_get_event_color($node) {
  $term_field_name = 'field_event_organization';
  if ($terms_for_entity = field_get_items('node', $node, $term_field_name)) {
    foreach ($terms_for_entity as $delta => $item) {
      $term_for_entity = taxonomy_term_load($item['tid']);
      if ($term_for_entity) {
        if (isset($term_for_entity->field_ev_legend_color['und'][0]['rgb'])) {
          return $term_for_entity->field_ev_legend_color['und'][0]['rgb'];
        }
        else {
          return sprintf('#%06X', mt_rand(0, 0xFFFFFF));
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function events_event_form_ev_event_node_form_alter(&$form, &$form_state, $form_id) {
  // Get organisations from the current user.
  $organisations = events_config_get_user_organizations();
  if ($organisations) {
    // Make sure already stored organisation is part of the options.
    if (isset($form['field_event_organization']['und']['#default_value']) && !empty($form['field_event_organization']['und']['#default_value'])) {
      if (!array_key_exists($form['field_event_organization']['und']['#default_value'][0], $organisations)) {
        $organisations[$form['field_event_organization']['und']['#default_value'][0]] = $form['field_event_organization']['und']['#default_value'][0];
      }
    }

    // Keep organisations defined in both.
    $intersect = array_intersect_key($form['field_event_organization']['und']['#options'], $organisations);
    $form['field_event_organization']['und']['#options'] = $intersect;
  }
}

/**
 * Implements hook_views_plugins_alter().
 */
function events_event_views_plugins_alter(&$plugins) {
  $plugins['row']['calendar_entity']['handler'] = 'events_event_calendar_plugin_row';
}

/**
 * Create the calendar date box.
 */
function events_event_preprocess_calendar_datebox(&$vars) {
  $date = $vars['date'];
  $view = $vars['view'];
  $vars['day'] = intval(substr($date, 8, 2));
  $force_view_url = !empty($view->date_info->block) ? TRUE : FALSE;
  $month_path = calendar_granularity_path($view, 'month');
  $year_path = calendar_granularity_path($view, 'year');
  $day_path = calendar_granularity_path($view, 'day');
  $vars['link'] = !empty($day_path) ? l($vars['day'], $day_path . '/' . $date) : $vars['day'];
  $vars['granularity'] = $view->date_info->granularity;
  $vars['mini'] = !empty($view->date_info->mini);
  if ($vars['mini']) {
    if (!empty($vars['selected'])) {
      $vars['class'] = 'mini-day-on';
    }
    else {
      $vars['class'] = 'mini-day-off';
    }
  }
  else {
    $vars['class'] = 'day';
  }
}
